{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "regex-input",
  "type": "registry:component",
  "registryDependencies": [
    "input"
  ],
  "files": [
    {
      "path": "components/domain-ui/regex-input.tsx",
      "content": "\"use client\";\n\nimport type * as React from \"react\";\nimport { Input } from \"@/registry/default/components/ui/input\";\nimport { useRegexInput } from \"@/registry/default/hooks/use-regex-input\";\n\nexport interface RegexInputProps extends React.ComponentProps<\"input\"> {\n  regex: RegExp;\n}\n\nexport function RegexInput({\n  regex,\n  value,\n  onChange,\n  ...props\n}: RegexInputProps) {\n  const { value: displayValue, onChange: handleChange } = useRegexInput({\n    regex,\n    value: value as string | undefined,\n    onChange: onChange\n      ? (newValue: string) => {\n          const syntheticEvent = {\n            target: { value: newValue },\n            currentTarget: { value: newValue },\n          } as React.ChangeEvent<HTMLInputElement>;\n          onChange(syntheticEvent);\n        }\n      : undefined,\n  });\n\n  return <Input {...props} value={displayValue} onChange={handleChange} />;\n}\n",
      "type": "registry:component"
    },
    {
      "path": "hooks/use-regex-input.ts",
      "content": "\"use client\";\n\nimport { useState, useCallback, useMemo } from \"react\";\n\n/**\n * REGEX INPUT VALIDATION FOR IDENTITY INPUTS\n *\n * A lightweight, library-free approach for identity inputs (PAN, SSN, passport, email, etc.)\n *\n * ## Algorithm:\n *\n * 1. **Pattern Analysis** (one-time):\n *    - Parse regex source string to identify character requirements per position\n *    - Extract character classes [A-Z], [0-9], literal chars, and quantifiers {n}\n *    - Detect case-sensitivity requirements for smart conversion\n *\n * 2. **Real-time Validation**:\n *    - For each character: lookup expected type at that position\n *    - Apply smart case conversion if needed (lowercase → uppercase)\n *    - Validate transformed character against allowed set\n *    - Stop processing on first invalid character\n *\n * 3. **Position Beyond Pattern**:\n *    - Once input reaches pattern end → REJECT ALL SUBSEQUENT INPUT\n *    - Natural length limiting without artificial constraints\n *    - Example: PAN has 10 positions → position 11+ rejected completely\n *\n * 4. **Smart Case Conversion**:\n *    - [A-Z] only → auto-convert lowercase to uppercase\n *    - [a-z] only → auto-convert uppercase to lowercase\n *    - [A-Za-z] mixed → no conversion (both allowed)\n *    - Algorithm:\n *      a) Analyze if position expects only upper/lower case\n *      b) If wrong case provided: convert before validation\n *      c) Validate transformed character against allowed set\n *\n * ## Examples:\n *\n * **PAN: /^[A-Z]{3}[PCFTABGHLJE]{1}[A-Z]{1}[0-9]{4}[A-Z]{1}$/\n * - Positions 0-2: Uppercase letters (convert lowercase)\n * - Position 3: Specific letters P,C,F,T,A,B,G,H,L,J,E (convert lowercase)\n * - Position 4: Uppercase letters (convert lowercase)\n * - Positions 5-8: Digits only\n * - Position 9: Uppercase letters (convert lowercase)\n * - Position 10+: NO RULES → ALL INPUT REJECTED\n *\n * **Input \"abcp1234f\":**\n * - 'a' → 'A', 'b' → 'B', 'c' → 'C', 'p' → 'P', '1234', 'f' → 'F'\n * - Result: \"ABCP1234F\" ✅\n *\n * **Input \"abcp1234fx\" (11th character):**\n * - First 10 chars processed normally\n * - 'x' at position 10: NO RULE → REJECTED\n * - Result: \"ABCP1234F\" (stops at 10 chars)\n *\n * ## Performance: O(1) per character, zero dependencies\n */\n\n// Character set constants for efficiency and clarity\nconst UPPERCASE_LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst LOWERCASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\";\nconst DIGITS = \"0123456789\";\nconst WHITESPACE = \" \\t\\n\\r\\f\\v\";\n\n// Regex constants for performance\nconst UPPERCASE_REGEX = /[A-Z]/;\nconst LOWERCASE_REGEX = /[a-z]/;\n\ntype CharacterType = \"uppercase\" | \"lowercase\" | \"digits\" | \"mixed\" | \"custom\";\n\ninterface PositionRule {\n  type: CharacterType;\n  allowedChars: string; // Only used for 'custom' type like [PCFTABGHLJE]\n}\n\n// Get character set for a given type\nconst getCharacterSet = (type: CharacterType, customChars?: string): string => {\n  switch (type) {\n    case \"uppercase\":\n      return UPPERCASE_LETTERS;\n    case \"lowercase\":\n      return LOWERCASE_LETTERS;\n    case \"digits\":\n      return DIGITS;\n    case \"mixed\":\n      return UPPERCASE_LETTERS + LOWERCASE_LETTERS + DIGITS;\n    case \"custom\":\n      return customChars || \"\";\n    default:\n      return \"\"; // Unknown types → empty string → no characters allowed → reject all input\n  }\n};\n\n// Check if character is valid for the rule type\nconst isCharacterValid = (char: string, rule: PositionRule): boolean => {\n  const allowedSet = getCharacterSet(rule.type, rule.allowedChars);\n  return allowedSet.includes(char);\n};\n\n// Apply smart case conversion based on rule type\nconst transformCharacter = (char: string, rule: PositionRule): string => {\n  switch (rule.type) {\n    case \"uppercase\":\n      // Convert lowercase to uppercase\n      return char >= \"a\" && char <= \"z\" ? char.toUpperCase() : char;\n    case \"lowercase\":\n      // Convert uppercase to lowercase\n      return char >= \"A\" && char <= \"Z\" ? char.toLowerCase() : char;\n    case \"custom\": {\n      // For custom sets like [PCFTABGHLJE], check if it's uppercase-only\n      const isUppercaseSet =\n        rule.allowedChars === rule.allowedChars.toUpperCase() &&\n        UPPERCASE_REGEX.test(rule.allowedChars) &&\n        !LOWERCASE_REGEX.test(rule.allowedChars);\n      return isUppercaseSet && char >= \"a\" && char <= \"z\"\n        ? char.toUpperCase()\n        : char;\n    }\n    default:\n      return char; // No transformation for mixed, digits, or unknown types\n  }\n};\n\n// Helper to process character class patterns\nconst processCharacterClass = (\n  pattern: string,\n  i: number,\n  position: number,\n  rules: Map<number, PositionRule>\n): { newPosition: number; newIndex: number } => {\n  const endBracket = pattern.indexOf(\"]\", i);\n  if (endBracket === -1) {\n    return { newPosition: position, newIndex: i + 1 };\n  }\n\n  const charClass = pattern.slice(i + 1, endBracket);\n  const rule = parseCharacterClass(charClass);\n  const quantifier = parseQuantifier(pattern, endBracket + 1);\n  const repeatCount = quantifier.count;\n\n  // Apply rule to multiple positions\n  let currentPosition = position;\n  for (let j = 0; j < repeatCount; j++) {\n    rules.set(currentPosition, rule);\n    currentPosition++;\n  }\n\n  return {\n    newPosition: currentPosition,\n    newIndex: endBracket + 1 + quantifier.consumed,\n  };\n};\n\n// Helper to process meta character patterns\nconst processMetaCharacter = (\n  pattern: string,\n  i: number,\n  position: number,\n  rules: Map<number, PositionRule>\n): { newPosition: number; newIndex: number } => {\n  const metaChar = pattern[i + 1];\n  if (!metaChar) {\n    return { newPosition: position, newIndex: i + 2 };\n  }\n\n  const rule = parseMetaCharacter(metaChar);\n  const quantifier = parseQuantifier(pattern, i + 2);\n  const repeatCount = quantifier.count;\n\n  // Apply rule to multiple positions\n  let currentPosition = position;\n  for (let j = 0; j < repeatCount; j++) {\n    rules.set(currentPosition, rule);\n    currentPosition++;\n  }\n\n  return {\n    newPosition: currentPosition,\n    newIndex: i + 2 + quantifier.consumed,\n  };\n};\n\n// Helper to process literal characters\nconst processLiteralCharacter = (\n  pattern: string,\n  i: number,\n  position: number,\n  rules: Map<number, PositionRule>\n): { newPosition: number; newIndex: number } => {\n  const literalChar = pattern[i];\n  if (!literalChar) {\n    return { newPosition: position, newIndex: i + 1 };\n  }\n\n  const rule: PositionRule = {\n    type: \"custom\",\n    allowedChars: literalChar,\n  };\n\n  rules.set(position, rule);\n  return { newPosition: position + 1, newIndex: i + 1 };\n};\n\n// Simple pattern analysis for common identity input patterns\nconst analyzeSimplePattern = (regex: RegExp): Map<number, PositionRule> => {\n  const source = regex.source;\n  const rules = new Map<number, PositionRule>();\n  const pattern = source.replace(/^\\^|\\$$/g, \"\");\n\n  let position = 0;\n  let i = 0;\n\n  while (i < pattern.length) {\n    if (pattern[i] === \"[\") {\n      const result = processCharacterClass(pattern, i, position, rules);\n      position = result.newPosition;\n      i = result.newIndex;\n    } else if (pattern[i] === \"\\\\\" && i + 1 < pattern.length) {\n      const result = processMetaCharacter(pattern, i, position, rules);\n      position = result.newPosition;\n      i = result.newIndex;\n    } else {\n      const result = processLiteralCharacter(pattern, i, position, rules);\n      position = result.newPosition;\n      i = result.newIndex;\n    }\n  }\n\n  return rules;\n};\n\n// Helper to check common character class patterns\nconst parseCommonPatterns = (charClass: string): PositionRule | null => {\n  if (charClass === \"A-Z\") {\n    return { type: \"uppercase\", allowedChars: \"\" };\n  }\n  if (charClass === \"a-z\") {\n    return { type: \"lowercase\", allowedChars: \"\" };\n  }\n  if (charClass === \"0-9\") {\n    return { type: \"digits\", allowedChars: \"\" };\n  }\n  if (charClass === \"A-Za-z\") {\n    return { type: \"mixed\", allowedChars: \"\" };\n  }\n  if (charClass === \"A-Z0-9\") {\n    return { type: \"mixed\", allowedChars: \"\" };\n  }\n  return null;\n};\n\n// Helper to expand character ranges like A-Z, a-z, 0-9\nconst expandCharacterRanges = (charClass: string): string => {\n  let expandedChars = \"\";\n  const ranges = charClass.match(/.-./g) || [];\n\n  for (const range of ranges) {\n    const start = range.charCodeAt(0);\n    const end = range.charCodeAt(2);\n    for (let code = start; code <= end; code++) {\n      expandedChars += String.fromCharCode(code);\n    }\n  }\n\n  return expandedChars;\n};\n\n// Helper to add individual characters from character class\nconst addIndividualChars = (\n  charClass: string,\n  expandedChars: string\n): string => {\n  const individuals = charClass.replace(/.-./g, \"\");\n  let result = expandedChars;\n\n  for (const individualChar of individuals) {\n    if (!result.includes(individualChar)) {\n      result += individualChar;\n    }\n  }\n\n  return result;\n};\n\n// Helper to determine character type based on content\nconst determineCharType = (chars: string): CharacterType => {\n  let hasUppercase = false;\n  let hasLowercase = false;\n\n  for (const char of chars) {\n    if (char >= \"A\" && char <= \"Z\") {\n      hasUppercase = true;\n    }\n    if (char >= \"a\" && char <= \"z\") {\n      hasLowercase = true;\n    }\n  }\n\n  if (hasUppercase && !hasLowercase) {\n    return \"uppercase\";\n  }\n  if (hasLowercase && !hasUppercase) {\n    return \"lowercase\";\n  }\n  return \"custom\";\n};\n\n// Parse character class like \"A-Z\", \"0-9\", \"A-Za-z\", \"PCFTABGHLJE\"\nconst parseCharacterClass = (charClass: string): PositionRule => {\n  // Check common patterns first\n  const commonPattern = parseCommonPatterns(charClass);\n  if (commonPattern) {\n    return commonPattern;\n  }\n\n  // Handle ranges\n  if (charClass.includes(\"-\")) {\n    let expandedChars = expandCharacterRanges(charClass);\n    expandedChars = addIndividualChars(charClass, expandedChars);\n\n    const charType = determineCharType(expandedChars);\n\n    return {\n      type: charType === \"custom\" ? \"custom\" : charType,\n      allowedChars: charType === \"custom\" ? expandedChars : \"\",\n    };\n  }\n\n  // Custom character set like \"PCFTABGHLJE\"\n  return { type: \"custom\", allowedChars: charClass };\n};\n\n// Parse meta characters like \\d, \\w, \\s\nconst parseMetaCharacter = (metaChar: string): PositionRule => {\n  switch (metaChar) {\n    case \"d\":\n      return { type: \"digits\", allowedChars: \"\" };\n    case \"w\":\n      return { type: \"mixed\", allowedChars: \"\" }; // \\w includes letters, digits, underscore\n    case \"s\":\n      return { type: \"custom\", allowedChars: WHITESPACE };\n    default:\n      return { type: \"custom\", allowedChars: \"\" };\n  }\n};\n\n// Parse quantifiers like {3}, {1,5}\nconst parseQuantifier = (\n  pattern: string,\n  startIndex: number\n): { count: number; consumed: number } => {\n  if (startIndex >= pattern.length || pattern[startIndex] !== \"{\") {\n    return { count: 1, consumed: 0 };\n  }\n\n  const endBrace = pattern.indexOf(\"}\", startIndex);\n  if (endBrace === -1) {\n    return { count: 1, consumed: 0 };\n  }\n\n  const quantifierContent = pattern.slice(startIndex + 1, endBrace);\n  const count = Number.parseInt(quantifierContent.split(\",\")[0] || \"1\", 10);\n\n  return { count, consumed: endBrace - startIndex + 1 };\n};\n\nexport interface UseRegexInputProps {\n  regex: RegExp;\n  value?: string;\n  onChange?: (value: string) => void;\n}\n\nexport const useRegexInput = ({\n  regex,\n  value: controlledValue,\n  onChange,\n}: UseRegexInputProps) => {\n  const [uncontrolledValue, setUncontrolledValue] = useState(\"\");\n  const value =\n    controlledValue !== undefined ? controlledValue : uncontrolledValue;\n\n  // Parse regex to get position-based rules (memoized)\n  const positionRules = useMemo(() => {\n    return analyzeSimplePattern(regex);\n  }, [regex]);\n\n  const isValid = useMemo(() => {\n    return regex.test(value);\n  }, [value, regex]);\n\n  const validateAndTransformChar = useCallback(\n    (\n      inputChar: string,\n      position: number\n    ): { isValid: boolean; transformedChar: string } => {\n      const rule = positionRules.get(position);\n\n      // If no rule found, this position is beyond the pattern length\n      // REJECT ALL SUBSEQUENT INPUT\n      if (!rule) {\n        return { isValid: false, transformedChar: inputChar };\n      }\n\n      // Apply smart case conversion\n      const transformedChar = transformCharacter(inputChar, rule);\n\n      // Check if the transformed character is valid\n      const isCharValid = isCharacterValid(transformedChar, rule);\n\n      return { isValid: isCharValid, transformedChar };\n    },\n    [positionRules]\n  );\n\n  const handleChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value;\n\n      // Validate and transform each character at its position\n      let validatedValue = \"\";\n      for (let i = 0; i < newValue.length; i++) {\n        const currentChar = newValue[i];\n        if (!currentChar) {\n          continue;\n        }\n\n        const { isValid: isCharValid, transformedChar } =\n          validateAndTransformChar(currentChar, i);\n\n        if (isCharValid) {\n          validatedValue += transformedChar;\n        } else {\n          // Reject invalid character - ALL SUBSEQUENT INPUT REJECTED\n          break;\n        }\n      }\n\n      if (controlledValue === undefined) {\n        setUncontrolledValue(validatedValue);\n      }\n      if (onChange) {\n        onChange(validatedValue);\n      }\n    },\n    [validateAndTransformChar, controlledValue, onChange]\n  );\n\n  return {\n    value,\n    onChange: handleChange,\n    isValid,\n  };\n};\n",
      "type": "registry:hook"
    }
  ],
  "meta": {
    "tags": [
      "input",
      "regex",
      "validation",
      "form"
    ]
  }
}